---
title: 浮点数四则运算
date: 2018-11-18 19:49:22
tags: 浮点数
---

项目地址：[https://github.com/wangxiaofeid/float.js](https://github.com/wangxiaofeid/float.js)

### 为何浮点数运算时会失精
计算机运算时二进制的，而有些浮点数转换成二进制的时候是无限循环的，eg: 0.1
```
0.1 * 2 = 0.2 # 0
0.2 * 2 = 0.4 # 0
0.4 * 2 = 0.8 # 0
0.8 * 2 = 1.6 # 1
0.6 * 2 = 1.2 # 1
0.2 * 2 = 0.4 # 0
.....
```
但计算机内存有限，我们不能用储存所有的小数位数，达到某个精度点会直接舍弃；有些误差可以相互抵消，但是有些就会相互叠加，这就造成了0.1+0.2!=0.3

### 怎么做
#### 浮点数拆分成
```
1.12 => {left: 1, right: 12, length: 2}
1.1 => {left: 1, right: 1, length: 1}
-1.12 => {left: -1, right: -2, length: 2}
```
#### 两个数小数位位数同步
```
1.12 => {left: 1, right: 12, length: 2}
1.1 => {left: 1, right: 10, length: 2}
```
#### 运算
1. 加法
  * 整数部分相加
  * 小数部分相加
  * 判断是否需要进位或者退位（如果小数位相加后的大小大于他们的位数即需要进位）
  * parseFloat
2. 乘法
  * (l1 + r1) * (l2 + r2) = l1*l2 + l1*r2 + r1*l2 + r1*r2
  * 对四部分进行因为运算，比如r1*r2 = 10 * 12 = 120 = 0.012 --> 因为两位小数和两位小数相乘后得到的数是四位小数
  * 对四部分进行相加操作


### 为何没有除法
除法本身就有除不尽的时候

### 为何不直接把浮点数直接移位成整数，再运算，在移位回去
这样做后方法可计算的范围将大大变小，比如：
假如系统最大运算的数字是整数部分32位，小数部分32位，在这种前提下做加法运算的位数将缩小一半，最大能支持的是小数和整数部分一起是32位的数字。